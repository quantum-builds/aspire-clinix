generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Patient {
  id               String             @id @default(cuid())
  email            String             @unique
  address          String?
  dateOfBirth      DateTime?
  mobileNumber     String?            @unique
  name             String?
  userId           String             @unique
  Appointment      Appointment[]
  User             User               @relation(fields: [userId], references: [id])
  PatientTreatment PatientTreatment[]
  ReferralForm     ReferralForm[]
  Dentist          Dentist[]          @relation("PatientDentists")
}

model Dentist {
  id                String             @id @default(cuid())
  email             String             @unique
  GDCnumber         String?            @unique
  address           String?
  mobileNumber      String?            @unique
  name              String?
  specialty         String?
  userId            String             @unique
  yearsOfExperience Int?
  Appointment       Appointment[]
  User              User               @relation(fields: [userId], references: [id])
  PatientTreatment  PatientTreatment[]
  ReferralForm      ReferralForm[]
  Patient           Patient[]          @relation("PatientDentists")
}

model ReferralForm {
  id                    String   @id @default(cuid())
  medicalHistory        String?
  createdAt             DateTime @default(now())
  referralDetails       String[]
  treatmentDetails      String?
  DOB                   String
  address               String
  email                 String
  mobileNumber          String
  name                  String
  other                 String?
  referralAddress       String
  referralEmail         String
  referralGDC           String
  referralMobileNumber  String
  referralName          String
  treatMeantAppointment String
  dentistId             String
  patientId             String
  Dentist               Dentist  @relation(fields: [dentistId], references: [id])
  Patient               Patient  @relation(fields: [patientId], references: [id])

  @@unique([patientId, dentistId])
}

model Appointment {
  id                String   @id @default(cuid())
  dentistId         String
  appointmentDate   DateTime
  appointmentStatus String?
  patientId         String
  downloadReport    String?
  service           String
  Dentist           Dentist  @relation(fields: [dentistId], references: [id])
  Patient           Patient  @relation(fields: [patientId], references: [id])

  @@unique([dentistId, patientId, appointmentDate])
}

model PatientTreatment {
  id              String    @id @default(cuid())
  dentistId       String
  patientId       String
  treatmentId     String
  treatmentDate   DateTime
  treatmentStatus String
  Dentist         Dentist   @relation(fields: [dentistId], references: [id])
  Patient         Patient   @relation(fields: [patientId], references: [id])
  Treatment       Treatment @relation(fields: [treatmentId], references: [id])

  @@unique([patientId, treatmentId, treatmentDate])
}

model Treatment {
  id               String             @id @default(cuid())
  name             String             @unique
  description      String
  cost             Decimal            @db.Decimal(10, 2)
  PatientTreatment PatientTreatment[]
}


// TODO: need to uncomment Payment Payment[]

model User {
  id       String   @id @default(cuid())
  email    String   @unique
  password String
  role     String
  Admin    Admin?
  Dentist  Dentist?
  Invoices Invoice?
  Patient  Patient?
  // Payment  Payment[]
  plans UserSubscribedPlans[]
}

model Invoice {
  id              String        @id @default(cuid())
  userId          String        @unique
  month           Int
  year            Int
  totalAmount     Float
  stripePaymentId String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  status          InvoiceStatus @default(PENDING)
  User            User          @relation(fields: [userId], references: [id])
  Payment         Payment[]
}


// TODO : need to make userId unique and add uncomment the User User

model Payment {
  id              String        @id @default(cuid())
  userId          String          
  invoiceId       String?
  stripePaymentId String        @unique
  amount          Float
  status          PaymentStatus @default(PENDING)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  Invoice         Invoice?      @relation(fields: [invoiceId], references: [id])
  // User            User          @relation(fields: [userId], references: [id])
}

model Plan {
  id            String    @id @default(uuid())
  name          String
  description   String
  price         Float   // Supports one-time or installment-based pricing
  validity      Int       // Duration in months (e.g., 6, 12)
  includedTreatments String[]
  discountId    String?
  discounts     Discount? @relation(fields: [discountId], references: [id])
  status        PlanStatus @default(ACTIVE)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  users UserSubscribedPlans[]
}

model Discount {
  id         String  @id @default(uuid())
  type       DiscountType
  value      Float // Percentage or fixed amount
  expiresAt  DateTime?
  plans      Plan[]
}
model UserSubscribedPlans{
  userId String 
  user User @relation(fields: [userId],references: [id])
  planId String
  plans Plan @relation(fields: [planId],references: [id])
  subscribedAt DateTime

  @@unique([userId,planId])
}


model Admin {
  id     String @id @default(cuid())
  userId String @unique
  email  String @unique
  User   User   @relation(fields: [userId], references: [id])
}

enum InvoiceStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

enum PaymentStatus {
  PENDING
  SUCCESSFUL
  FAILED
}

enum PlanStatus {
  ACTIVE
  EXPIRED
  UPCOMING
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}
